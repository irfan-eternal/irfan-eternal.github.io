[{"categories":["Malware Analysis"],"content":"Understanding Internals of SmokeLoader","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Introduction In this blog we will be discussing about Understanding Internals of SmokeLoader using Ghidra ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:1:0","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Analysis For readers who want to Follow along can get the sample from MalwareBazaar .The sample was first Seen on September 5th 2023 14:12:29 UTC . The sample is 32bit Exe File You can use the tool of your Choice i will be using Ghidra in this blog. The Sample Consists of 3 Stages. In the next sections we will look at each Stages in Detail ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:2:0","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Stage 1 The Primary Job of Stage 1 is to Write a new Image to Memory which is the Second Stage ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:3:0","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Shellcode Allocation and Calling The Stage 1 Allocates a Executable Memory in Virtual address space using VirtualAlloc. Writes Shellcode to this address space whose job is to Load the new Image in to Memory It Calls the Shellcode from Address 40404a If you want to Dump this Shellcode and Understand What it is doing you Can put a Breakpoint on this Location . Stepin to this Call and dump this portion or Follow it in Debugger to Understand What it’s doing ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:3:1","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Loading New Image to Memory The Shellcode first Dynamically Resolves API Call. It uses StackStrings and GetProcAddress to do this Using the Dynamically Resolved API Calls it Loads the New Image to Memory by Parsing PE Headers. If you have a good Understaing of PE File Formats and it’s offsets the below image will make Sense to you Some PE File Format offsets i want you take a note is 0x3c and 0x78 . Offset 0x3c is aslo called as e_lfanew it is the File address of new exe header .e_lfanew* + 0x78 gives us the ExportDirectory Virtual Address After this Shellcode is Comletely executed the New Image will be Loaded in the Memory. You can dump the Second stage from memory Now ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:3:2","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Stage 2 Stage 2 is Very Obfuscated Stage with Multiple Anti-Analysis Techniques to Frustrate the Malware Analyst working on it. It Includes Anti-Vm Checks, Encrypted Function code only Decrypted prior to it’s execution, API Hashing etc… The Final Goal of this Stage is to Inject the Third Stage to explorer.exe ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:4:0","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Weird Conditional Jumps This Stage Contains Weird Conditional Jumps as Show in the below image . They are JNZ and JZ jumps with same Destination Address. This is Infact an Unconditional Jump. The Malware is using this technique make it hard for the Disassembler and Decompiler We can Fix this Easily by finding all the Places with this weird Conditional Jumps and patching it with unconditional Jump. def handleDoubleConditionalJumps(): address_array = findBytes(currentProgram.getMinAddress(), b'\\x75.\\x74.', 1000) address_array += findBytes(currentProgram.getMinAddress(), b'\\x74.\\x75.', 1000) for addr in address_array: jmp_bytes = getBytes(addr, 4) if jmp_bytes[1] - jmp_bytes[3] == 2: clearListing(addr) dis.disassemble(addr, None) patch_instruction = bytearray() patch_instruction.append(0xeb) patch_instruction.append(jmp_bytes[1]) patch_instruction.append(0x90) patch_instruction.append(0x90) patch_instruction2 = bytes(patch_instruction) clearListing(addr) clearListing(addr.add(2)) clearListing(addr.add(3)) block = mem.getBlock(addr) block.putBytes(addr,patch_instruction2 ) dis.disassemble(addr, None) jmp_instr = getInstructionAt(addr) new_jmp = jmp_instr.getDefaultFlows()[0] new_jmp2 = new_jmp for i in range(50): clearListing(new_jmp2) new_jmp2 = new_jmp2.add(1) if new_jmp2.getAddress == currentProgram.getMaxAddress(): break The Above Python Code does this using Ghidra API After we run this Script all the Weird Conditonal Jumps will be patched to Unconditional jumps and Disasseblers and Decompilera will give us a Better Output. The Below images Shows us the Sample after Execution of th Script ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:4:1","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Control Flow Obfuscation This stage’s Control Flow is Obfuscated with the use of Anti-Debugging Checks In the Below Image malware uses PEB’s BeingDebugged Field (Offset 0x2) to Check if Process is Being Debugged. If it’s not being Debugged the Offset will contain 0, which is used to Calculate the address where the Control flow is Transfered. If the process is being Debugged the Offset will Contain 1 and will lead to Exception An other Anti-Deugging Technique it uses is the NtGlobalFlag Field( offset 0x68) in the PEB to Check if it’s Being Debugged. If it’s not being Debugged the Offset will contain 0, which is used to Calculate the address where the Control flow is Transfered. If the process is being Debugged the Offset will Contain 0x70 and will lead to Exception ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:4:2","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Encrypted Function Code One of the most distinctive feature about SmokeLoader is that most of the Function code are in the Encrypted form. They will only be Decrypted just before execution of that code. And will be re-encrypted after that code has been executed The above image show an Example how the Code look like before Encryption The decryption_function in the above image is the function which decrypts the Code. It is a normal XOR Decrption. The Function takes three parameters. Size of the code to be decrypted XOR Key used RVA of the Starting of the Code that need to be decrypted. You can use the below function to Decrypt one function at a time def decryptShellcode(size, xor_key, rva): va = rva + 0x400000 va = hex(va)[2:] addr = toAddr(va) addr2 = addr enc = get_bytes(toAddr(va), size) for i in range(size): clearListing(addr2) addr2 = addr2.add(1) size2 = size for i in range(0,size): enc[i] = enc[i]^xor_key for i in enc: i = i \u0026 0xFF setByte(addr, i) addr = addr.add(1) The Below Image Shows the same code after Decryption. The last call to 40131a is wrapper for decryption_function, which will cause the code to be re-encrypted ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:4:3","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"API Hashing The Hashing Algorithm used in 2nd Stage is DJB2 hasing Algorithm. In the below image you can see the decompiled code for this. If you are having trouble Understanding this Code i would ask you to read this blog . It Explains in Detail about API Resolving You can use the below python function to find the values of hashes of the API’s you need. def api_hashing(): api_list = [] hasher = 0x1505 hash2 = 0 for a in api_list: hasher = 0x1505 hash2 = 0 for i in a: i = ord(i) hash2 = hasher hasher = hasher \u003c\u003c 5 hasher = hasher \u0026 0xFFFFFFFF hasher = hasher + hash2 hasher = hasher \u0026 0xFFFFFFFF hasher = hasher + i hasher = hasher \u0026 0xFFFFFFFF hash2 = hasher hasher = hasher \u003c\u003c 5 hasher = hasher \u0026 0xFFFFFFFF hasher = hasher + hash2 hasher = hasher \u0026 0xFFFFFFFF hasher2 = hex(hasher)[2:-1] if len(hasher2)!= 8: hasher2 = \"0\"+hasher2 print(\"API Name : \"+a+\" Address : \"+addresss) ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:4:4","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Checks KeyBoard Layout Next the malware checks the keyboard layout of the device. If it’s Russian(0x419) or Ukranian(0x422) the malware won’t do any malicious activites. If this is not the case it continues doing it’s Buisness ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:4:5","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Previliges Check The Malware Check if it’s running with Higher Previliges using this API Call’s OpenProcessToken -\u003e GetTokenInformation(TokenIntegrityLabel) -\u003e GetSidSubAuthority It is Checking if the Integrity level is above 0x2000 (SECURITY_MANDATORY_MEDIUM_RID ) If the values greater than 0x2000, it is high integrity. If the user is local admin, but a process was executed normaly, you have the medium integrity Level. If the user clicks run as administrator you would have 0x3000. If this is not the Case it will use Run As Administrator Option to get Higher privileges ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:4:6","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"API Resolving for APIs of NTDLL The Malware Then Open’s a handle ntdll.dll with shareMode set to 0,Creates a file mapping object for ntdll, Maps a view of this file mapping into the address space of the Malicious process and does API resolving using the Same Hash Algorithm (djb2) in this mapped View. This is to make sure no APIs are being hooked by EDR ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:4:7","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Anti-Sandbox, Anti-Emulator and Anti-VM Techniques The Malware has Multiple Checks to detect if it’s in a VM or sandbox. In the below Image malware is checking if the dlls sbidedll(Sandboxie), aswhook(Avast) and snxhk(Symantec) are mapped into malicious process address space. These DLLs are related to Sandbox solution or Anti-Virus products, another interesting thing to note is that the arguments are stored in the return adress of the function Another check used by the malware is to check in the Registry Tree for device and drivers if it contains anything related to Virtual machines. It Opens the Registry keys SYSTEM\\CurrentControlSet\\Enum\\IDE and SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum\\SCSI using NtOpenKey and gets and the number and sizes of its subkeys using NtQueryKey It then uses NtEnumerateKey to get the information about the subkeys and check if this subkeys contains the strings qemu, virtio, vmware, vbox, xen . These strings are related to Emulators and Virtual Machines The Next check it uses is to detect Emulators . It Checks Current Process’ File path with AFEA.vmt using wcsstr this is a Technique called error-based anti-sandbox check. It is explained in detail by herrcore in this video ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:4:8","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Injection of Third Stage using Heavens Gate Technique The Malware First Checks if it’s running on a 64 bit or 32 bit System by looking at the GS Register because GS is non-zero in Win64 and In a ’true’ 32 bit Windows GS is always zero.. If it’s running on a 64 bit System it uses Heavens Gate technique .“Heaven’s Gate” is a technique used to run a 64-bit code from a 32-bit process, or 32-bit code from a 64-bit process .To know more about this technique I request you to refer this article Here it is used to run 64-bit code from a 32-bit process for Injection of the Third Stage. If the System only supports 32 bit it Executes the Code shown in the Below Image The third Stage is injected to explorer.exe. It uses GetShellWindow and GetWindowThreadProcessId to get the process ID of explorer.exe. It then uses NtOpenProcess and NtDublicateObject to create a duplicate handle for explorer.exe. It then creates a section then Maps the same section to malicious process and explorer.exe. Another section is also created and this process is again repeated. The third stage is then written to this section in the malicious Process. Since explorer.exe also has the same section mapped it will also have the third Stage in it’s Memory. Then RtlCreateUserThread is used to Execute the Malicious third stage from explorer.exe’s address space if the System supports 64 bit. It Decrpyts the 64 bit code for Injection and uses heaven’s gate technique technique to excecute this. The process of Injection is same for Both. In the below images you can see the 64 bit code which dynamically resolves RtlCreateUserThread API and it is then used to Execute the malicious third stage from explorer.exe’s address space To get the third stage you can set the GS register to 0 in the debugger at the time of injection, set shareMode to FILE_SHARE_READ (0x00000001) when opening handle to ntdll.dll and defeat all the Anti-Analysis techniques mentioned to get the third Stage in explorer.exe and dump it. You can aslo get the entrypoint of the function if you look at the parameters of the RtlCreateUserThread ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:4:9","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Stage 3 The Main objective of this stage is to Decrypt C2 URl Communicate to C2 and Download the Final payload. This stage is also responsible for Persistnace of the Malware ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:5:0","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Dynamic API Resolving using API Hashing Third stage of the malware has a Different set of API resolving . it uses ROL8 hashing you can see the algorithm in the below image It uses this Hashing Algoritm to resolve APIs in multiple DLLs’ (kernel32, ntdll, user32, advapi32, ole32, winhttp and dnsapi) You can use the below code to get the Hashes of the APIs used in Third Stage def stage3ApiHashing(): api_list = [] hasher = 0 for api in api_list: hasher = 0 for i in api: i = ord(i) i = i \u0026 0xdf saved_val = i hasher = hasher ^ saved_val hasher = rol(hasher, 8) hasher = hasher \u0026 0xFFFFFFFF hasher = hasher + saved_val hasher = hasher \u0026 0xFFFFFFFF hasher = hasher ^ 0x38127ba6 hasher = hasher \u0026 0xFFFFFFFF print(hex(hasher)) hasher2 = hex(hasher)[2:-1] while len(hasher2)!= 8: hasher2 = \"0\"+hasher2 print(api+\" : \"+hex(hasher)) ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:5:1","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Encrypted Strings The Important Strings in the third Stage are Encrypted in a custom rc4 encryption algorithm. The Encrypted string is Stored in the Format of DataSize:Data When it Comes to the custom rc4 algorithm. The key Stream Generation is Different from the default rc4 algorithm the below image shows the decompiled view of the custom rc4 decryption algorithm I Have Converted it to python Here is the code to Decrypt the Strings def key_scheduling(key): sched = [i for i in range(0, 256)] i = 0 for j in range(0, 256): i = (i + sched[j] + key[j % len(key)]) % 256 tmp = sched[j] sched[j] = sched[i] sched[i] = tmp return sched def streamXor(data, key, data_len,key_len, shed): counter = 0 i = 0 j = i while data_len != 0: i = i+1 i = i \u0026 0XFF temp = shed[i] temp = temp \u0026 0xFF j = j + temp j = j \u0026 0xFF shed[i] = shed[j] shed[j] = temp shed_swap = shed[i] + temp shed_swap = shed_swap \u0026 0xFF data[counter] = data[counter] ^ shed[shed_swap] counter = counter +1 data_len = data_len -1 return data def customrc4(data, key, data_len,key_len): shed = key_scheduling(key) final_result = streamXor(data, key, data_len,key_len, shed) print(final_result) def main(): data = bytearray(b'\\xb2\\x16\\x17\\x9f\\x23\\x37') key = b'\\x29\\xc5\\xbd\\xe6' customrc4( data, key, 6, 4) main() The Decrypted Strings of the Third Stage can be seen in the Below Image ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:5:2","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Analysis Tools Check This Stage Checks if the system is running Analysis tools by looking at the Process name and Window Class name In the Below Image you can see the Malicious process Gettting the Name of all the Processes running, Calculates their Hashes using the algorithm used in Stage 3(ROL8 hashing ) and Check it against Hashes of Analysis tools shown in the image below. If they match, that Process is Terminated There is an Additional Check Which get the Class Name of all top-level windows on the screen. It then Calculates their Hashes using the algorithm used in Stage 3(ROL8 hashing ) and Check it against Hashes of Analysis tools shown in the image below. If they Match, the Process related to that window is Terminated ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:5:3","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Previliges Check The Same Previliges Check done in Stage 2 is done again Stage 3. The Malware Check if it’s running with Higher Prviliges using this API Call’s OpenProcessToken-\u003eGetTokenInformation(TokenIntegrityLabel)-\u003eGetSidSubAuthority It is Checking if the Integrity level is above 0x2000 (SECURITY_MANDATORY_MEDIUM_RID ) If the values greater than 0x2000, it is high integrity. If the user is local admin, but a process was executed normaly, you have the medium integrity Level. If the user clicks run as administrator you would have 0x3000. ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:5:4","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Mutex Check The Malware Uses the Computer Name and Volume Infromation to a Create a Formatted Data which is used as a Seed to Create an MD5 Hash with these Values. These Values is used in Multiple Places One of the most important Place these Value used is to Create a Mutex with this name. The Malware Creates a Mutex with this name and After that uses RtlGetLastWin32Error , if the return value is ERROR_ALREADY_EXIST Malware Exits the Thread. This is done by the malware to make sure the malware is run only once in a System ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:5:5","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Copy to New Path and use of Zone.Identifier The Malware Creates a File Path at AppData or Temp . Check if the File running is in this Path. If it is not Running on this path it Delete itself and Copy the File from Curent Location to the File Path Created at AppData or Temp One Important thing to note here is the Malware Also removes the Alternate Data Stream :Zone.Identifier . It Stores the Data whether the file was downloaded from the Internet. By Doing this System won’t Understand the File was downloaded from Internet ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:5:6","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Changing File Attributes and FileTime After Moving the File to Appdata or Temp . The Files Attribute is Changed to 6 ( FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN). This makes the File Hidden and operating system uses a part of, or uses this File exclusively. Then Malware Chnages the Malicious Files Creation Time , Last Access Time and Last Write Time to the Creation Time , Last Access Time and Last Write Time of advapi32.dll in System Dir. My Assumption for this Technique is that it is trying to not show it’s a New File ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:5:7","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Persistance The Persistance is Achieved by Creating a Scheduled task using ITaskService interface First it Deletes the Task with Name FireFox Default Browser Agent{MD5 Value Used to Create Mutex} . Then It Sets Author of the task as Current User. Then Trigger of the task is set when the Current User Logins in. The File path of Task is Set to the Malicious File Copied to AppData or Temp And It Finally Registers the task with name FireFox Default Browser Agent{MD5 Value Used to Create Mutex} ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:5:8","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"C2 Decryption and Communication The C2 URL’s are Encrypted using the Same Custom rc4 encryption Algorithm used in Stage3. The Data is also Stored in the Same format DataSize:Data. You can use the Same Decryprtion Function mentioned above to decrypt the Strings Here is the List of C2 URL’s i found in this Malware The malware then uses the c2 URL with WinHttp Library to Communicate to the C2 server Since It’s a Loader Based on C2 Response It Loads the Final Payload ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:5:9","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Indicators of Compromise Type Indicator Description SHA256 5c1735b8154391534f98e6399a2576a572c7fd3c51fa6ecc097434c89053b1f7 Initial File CnC hxxp://potunulit[.]org/ Command and Control CnC hxxp://hutnilior[.]net/ Command and Control CnC hxxp://golilopaster[.]org/ Command and Control CnC hxxp://newzelannd66[.]org/ Command and Control ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:6:0","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"References hsauers5 CryptDeriveKey Bing AI Image Generator ","date":"2024-01-06","objectID":"/understanding-internals-of-smokeloader/:7:0","tags":null,"title":"Understanding Internals of SmokeLoader","uri":"/understanding-internals-of-smokeloader/"},{"categories":["Malware Analysis"],"content":"Analysing .NET AsyncRAT using dnSpy","date":"2023-08-19","objectID":"/analysing-.net-asyncrat-using-dnspy/","tags":null,"title":"Analysing .NET AsyncRAT using dnSpy","uri":"/analysing-.net-asyncrat-using-dnspy/"},{"categories":["Malware Analysis"],"content":"Introduction Hi all, Today we will be analysing .NET AsynRAT using dnSpy.In this blog we will be discussing about static extraction of the Config and we will also look at some of the capabilites of AsyncRAT. ","date":"2023-08-19","objectID":"/analysing-.net-asyncrat-using-dnspy/:1:0","tags":null,"title":"Analysing .NET AsyncRAT using dnSpy","uri":"/analysing-.net-asyncrat-using-dnspy/"},{"categories":["Malware Analysis"],"content":"Analysis For readers who want to Follow along can get the sample from MalwareBazaar .The sample was first Seen on 2023-07-04 07:07:39 UTC . The sample is 32bit so you can use dnSpy 32 Bit Version. ","date":"2023-08-19","objectID":"/analysing-.net-asyncrat-using-dnspy/:2:0","tags":null,"title":"Analysing .NET AsyncRAT using dnSpy","uri":"/analysing-.net-asyncrat-using-dnspy/"},{"categories":["Malware Analysis"],"content":"Static Config Extraction When You go to the Entrypoint function Main there is a method called RBReueVXBVIYiq which sets all the Config Data. If you take a closer look you can understand a pattern. Most of the Config data is Set using the method isVjrDwVFds which takes a Field of eDraegaZqrr as an Argument. When You look at isVjrDwVFds it converts the argument from Base64 and call the method QpLgTABIbRB with the return value. Here is the actual decryption taking place. It uses AES CBC and SHA256 inside the decryption Function I tried using de4dot and Powershell to decrypt the config but they failed. So I tried to replicate the decryption function in Python Steps I followed for decryption Copy all the Content from the eDraegaZqrr Class Visit this Cyberchef Recipie and Paste the Contents of eDraegaZqrr Class . The Recipie uses this regex “(.*?)” to Get the Value of the fields from eDraegaZqrr Get the Config Extractor script from here and add the contents you got from Step2 as Elements of the array enc in main function and run the Script You will get all the Config Data import base64 from Crypto.Cipher import AES from Crypto.Protocol import KDF import hashlib import hmac def unpad(s): return s[:-ord(s[len(s)-1:])] def decrypt(enc): enc = base64.b64decode(enc) password = base64.b64decode(\"W1h0cU9mc0E3S0VFcEt1Y3F4d1BkZTRMTk1vZ1A5aWY=\"); salt = b'\\xbf\\xeb\\x1e\\x56\\xfb\\xcd\\x97\\x3b\\xb2\\x19\\x02\\x24\\x30\\xa5\\x78\\x43\\x00\\x3d\\x56\\x44\\xd2\\x1e\\x62\\xb9\\xd4\\xf1\\x80\\xe7\\xe6\\xc3\\x39\\x41' iteration = 50000 stream = hashlib.pbkdf2_hmac(\"shal\", password, salt, iteration, dklen = 100) aeskey = stream[:32] sha256key = stream[:62] HMACObject = hmac.new(sha256key, msg=enc[32:len(enc)-32], digestmod=hashlib.sha256) memoryStream = HMACObject.hexdigest() array2 = memoryStream[:32] iv = memoryStream[32:48] encrypted_text= bytes(memoryStream[48:], 'utf-8') plain = AES.new(aeskey, AES.MODE_CBC, bytes(iv, 'latin-1')) plain_text= unpad(plain.decrypt (enc)) return plain_text[48:] def main(): enc = [] for i in enc: decrypted_text = decrypt(i); print(decrypted_text) I tried de4dot and Powershell Scripts(Invoke) to decrypt the Config the Data but they failed. You can also decrypt the Config by debugging but you to need to pass all the Anti-Analysis checks Next we will look at the Capabilities of the AsyncRAT Sample ","date":"2023-08-19","objectID":"/analysing-.net-asyncrat-using-dnspy/:2:1","tags":null,"title":"Analysing .NET AsyncRAT using dnSpy","uri":"/analysing-.net-asyncrat-using-dnspy/"},{"categories":["Malware Analysis"],"content":"Anti-VM Technique The Sample uses WMI Queries to check the manufacturer details and check if it contains VM related strings like VirtualBox, vmware, VIRTUAL . if this is the case the malware Exits ","date":"2023-08-19","objectID":"/analysing-.net-asyncrat-using-dnspy/:2:2","tags":null,"title":"Analysing .NET AsyncRAT using dnSpy","uri":"/analysing-.net-asyncrat-using-dnspy/"},{"categories":["Malware Analysis"],"content":"Anti-Debugging Technique The Sample get the current process handle and uses CheckRemoteDebuggerPresent API to Check if there is any remote Debugger is Attached to the Process . if this is the case The malware Exits ","date":"2023-08-19","objectID":"/analysing-.net-asyncrat-using-dnspy/:2:3","tags":null,"title":"Analysing .NET AsyncRAT using dnSpy","uri":"/analysing-.net-asyncrat-using-dnspy/"},{"categories":["Malware Analysis"],"content":"Anti-Sandbox Technique The Malware checks if it is Running in any Sandbox environment by Checking if SbieDll.dll is Loaded into process memory . This DLL is used by some sandboxes. if SbieDll is present The malware Exits ","date":"2023-08-19","objectID":"/analysing-.net-asyncrat-using-dnspy/:2:4","tags":null,"title":"Analysing .NET AsyncRAT using dnSpy","uri":"/analysing-.net-asyncrat-using-dnspy/"},{"categories":["Malware Analysis"],"content":"Other Checks It also Checks the Drive Size if the Size is less than the Hardcoded Value the Malware Exits It Also Checks if the OSName contains XP if this is the case the Malware Exits ","date":"2023-08-19","objectID":"/analysing-.net-asyncrat-using-dnspy/:2:5","tags":null,"title":"Analysing .NET AsyncRAT using dnSpy","uri":"/analysing-.net-asyncrat-using-dnspy/"},{"categories":["Malware Analysis"],"content":"Persistance The Sample Checks whether it has Administrator privileges If yes it uses cmd to create a schedule task to achieve Persistance. If it is not an Administrator it uses the autorun key SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run to achieve Persistance ","date":"2023-08-19","objectID":"/analysing-.net-asyncrat-using-dnspy/:2:6","tags":null,"title":"Analysing .NET AsyncRAT using dnSpy","uri":"/analysing-.net-asyncrat-using-dnspy/"},{"categories":["Malware Analysis"],"content":"Stop From Termination If it has Adminstrator privileges it is given SeDebugPrivilege . By default, users can debug only processes that they own. By giving SeDebugPrivilege privilege it can debug processes owned by other users. After that it uses RtlSetProcessIsCritical API which set the process to a system critical status. This means that the process is now “critical” to the running of Windows, which also means that on termination of the process, Windows itself terminates as well. ","date":"2023-08-19","objectID":"/analysing-.net-asyncrat-using-dnspy/:2:7","tags":null,"title":"Analysing .NET AsyncRAT using dnSpy","uri":"/analysing-.net-asyncrat-using-dnspy/"},{"categories":["Malware Analysis"],"content":"Key Logging It uses SetWindowsHookEx API to install a Hook procedure on all low level keyboard input Events. it stores the key logging data in %temp%log.tmp file and Exfilterates this Data ","date":"2023-08-19","objectID":"/analysing-.net-asyncrat-using-dnspy/:2:8","tags":null,"title":"Analysing .NET AsyncRAT using dnSpy","uri":"/analysing-.net-asyncrat-using-dnspy/"},{"categories":["Malware Analysis"],"content":"Data Stealing and Exfilteration It Collects Basic Information Like Username, OS, Executable Path, Anti Viruses etc. It Also Steals Data from Browsers like Firefox, Brave, Chrome, Opera, Edge. It Also Checks For Crypto wallets like Binannce, Trust, MetaMask After Collection it Compresses the Data using GZip Stream and Exfilterates the Data to CnC josemonila[.]ddnsfree[.]com using Socket Class for CnC Communication ","date":"2023-08-19","objectID":"/analysing-.net-asyncrat-using-dnspy/:2:9","tags":null,"title":"Analysing .NET AsyncRAT using dnSpy","uri":"/analysing-.net-asyncrat-using-dnspy/"},{"categories":["Malware Analysis"],"content":"Indicators of Compromise Type Indicator Description SHA256 8da2ee52332138905d6c21a8c2fd16c1ccb16aa057b64df7e66f2bd38664e86f Initial File CnC josemonila[.]ddnsfree[.]com Exfilteration of Data Mutex AsyncMutex_6SI80kPnk To make sure to Run only once ","date":"2023-08-19","objectID":"/analysing-.net-asyncrat-using-dnspy/:3:0","tags":null,"title":"Analysing .NET AsyncRAT using dnSpy","uri":"/analysing-.net-asyncrat-using-dnspy/"},{"categories":["Malware Analysis"],"content":"References Stackoverflow codeproject ","date":"2023-08-19","objectID":"/analysing-.net-asyncrat-using-dnspy/:4:0","tags":null,"title":"Analysing .NET AsyncRAT using dnSpy","uri":"/analysing-.net-asyncrat-using-dnspy/"},{"categories":["Malware Analysis"],"content":"Guloader Deobfuscation using Ghidra","date":"2023-07-23","objectID":"/guloader-deobfuscation-using-ghidra/","tags":null,"title":"Guloader Deobfuscation using Ghidra","uri":"/guloader-deobfuscation-using-ghidra/"},{"categories":["Malware Analysis"],"content":"Introduction Hi all, Today we will be Analyzing Guloader Shellcode using Ghidra. Our Objective is to Identify some Anti-analysis and Obfuscation techniques used by Guloader and Defeat it using Automation. People who would like to follow along can download the sample from here . The File was was seen on 2023-05-11 ","date":"2023-07-23","objectID":"/guloader-deobfuscation-using-ghidra/:1:0","tags":null,"title":"Guloader Deobfuscation using Ghidra","uri":"/guloader-deobfuscation-using-ghidra/"},{"categories":["Malware Analysis"],"content":"Anti-Analysis / Obfuscation ","date":"2023-07-23","objectID":"/guloader-deobfuscation-using-ghidra/:2:0","tags":null,"title":"Guloader Deobfuscation using Ghidra","uri":"/guloader-deobfuscation-using-ghidra/"},{"categories":["Malware Analysis"],"content":"API Hashing The Shellcode is using API hashing to hide API’s being called. For Each API Resolving it first resolves LdrLoadDll add 5 to it’s address to avoid any Hooking done by EDR .Adding 5 to the API address is to avoid the classic 5 Byte Hook.Most EDR replaces first first bytes with a jump to EDR’s code. It then use this address to Load the DLL. after Loading the DLL . it resolves the hash of the API it needs to call API Hashing function is the same as we see in the wild. it goes to the Export Directory of the DLL Loaded and performs Hashing of all API name’s till the hashes match .if the hashes match it stores the Address of the API Hashing Algorithm : In the past Guloader was using just DJB2 hash . Now it xors the result of djb2 hash with a hardcoded value to perform API Hashing I wrote a python script to identify the Hashes of the API’s used by the past Guloaders to identify the Functionalities of the Code val = 0x1505 APIstrings = [\"NtGetContextThread\", \"RtlAddVectoredExceptionHandler\", \"NtAllocateVirtualMemory\", \"DbgUIRemoteBreakIn\", \"LdrLoadDll\", \"DbgBreakPoint\", \"EnumWindows\", \"NtSetInformationThread\", \"ZwSetInformationThread\", \"TerminateProcess\", \"ExitProcess\", \"NtSetContextThread\", \"NtWriteVirtualMemory\", \"NtCreateSection\", \"NtMapViewOfSection\", \"NtOpenFile\", \"NtSetInformationProcess\", \"NtClose\", \"NtResumeThread\", \"NtProtectVirtualMemory\", \"CreateProcessInternal\", \"GetLongPathNameW\", \"Sleep\", \"NtCreateThreadEx\", \"WaitForSingleObject\", \"TerminateThread\", \"CreateFileW\", \"WriteFile\",\"ReadFile\",\"ShellExecuteW\", \"RegCreateKeyExA\",\"RegSetValueExA\", \"NtQueryInformationProcess\", \"InternetOpenA\", \"InternetSetOptionA\", \"InternetOpenUrlA\", \"InternetReadFile\", \"InternetCloseHandle\"] for APIstring in APIstrings: val = 0x1505 for ch in instring: val += ((val \u003c\u003c5)) val \u0026= 0xFFFFFFFF val += ord(ch) val \u0026= 0xFFFFFFFF val ^= 0x8131A1 print(APIstring+\" : \"+hex(val)) ","date":"2023-07-23","objectID":"/guloader-deobfuscation-using-ghidra/:2:1","tags":null,"title":"Guloader Deobfuscation using Ghidra","uri":"/guloader-deobfuscation-using-ghidra/"},{"categories":["Malware Analysis"],"content":"Checks before Calling API’s Before Calling the API it performs some Checks to make sure it is not being Debugged It compares the first few bytes of the API address with a) CC b) INT 3 c) UD2 to check if it’s being Debugged. if this is not the case it calls the API ","date":"2023-07-23","objectID":"/guloader-deobfuscation-using-ghidra/:2:2","tags":null,"title":"Guloader Deobfuscation using Ghidra","uri":"/guloader-deobfuscation-using-ghidra/"},{"categories":["Malware Analysis"],"content":"Control Flow Obfuscation using Vectored Exception Handling To Obfuscate the Control Flow it uses RtlAddVectoredExceptionHandler to register a vectored Exception Handler. If the Exception raised is any of below three cases it changes the EIP by an XOR operation EXCEPTION_ACCESS_VIOLATION while accessed memory Address is 0 EXCEPTION_SINGLE_STEP (Single Stepping ) EXCEPTION_BREAKPOINT (Software Break Point - CC) If it is EXCEPTION_BREAKPOINT it calculates the value of the EIP by this expression EIP = EIP + *(EIP+1) ^ 6A (Changes with sample) If it is EXCEPTION_ACCESS_VIOLATION or EXCEPTION_SINGLE_STEP it calculates the value of the EIP by this expression EIP = EIP + *(EIP+2) ^ 6A (Changes with sample) . In the Vectored Exception Handler function it also checks if any Dynamic anyalsis is being performed by Checking if any hardware breakpoint is set using ContextRecord a member of _EXCEPTION_POINTERS To Understand Vectored Exception in Detail i would suggest to read this article ","date":"2023-07-23","objectID":"/guloader-deobfuscation-using-ghidra/:2:3","tags":null,"title":"Guloader Deobfuscation using Ghidra","uri":"/guloader-deobfuscation-using-ghidra/"},{"categories":["Malware Analysis"],"content":"Encrypted Strings All the Important strings including the C2 URL is Encrypted using XOR. The Encrypted strings are created by Performing a lot of Mathematical Expression(not Hardcoded).After Encryption String is Fully Created . The first Dword contains the length of the Encrypted string. then what follows is the Encrypted string. The Address of the Encrypted string is given as parameter to the String Decrpyion preperation Function. It store the Encrypted String length in a Varaible. And changes the First Dword to a Dummy Value . After that increments the Address of Encrypted String by a dword now it points to the Actual start of the String. Encrypted_string and the Encrypted String length is given an paramerers to the next Function called which is a wrapper around the string decryption function The wrapper function passes the Encrypted_string, Encrypted String length and the Key. The key is actually stored in the return address of the wrapper function The Decrytion Algorithm is a Simple XOR were Encrypted string is calculated by Mathematical Expression and key is stored in the the return address of the wrapper function ","date":"2023-07-23","objectID":"/guloader-deobfuscation-using-ghidra/:2:4","tags":null,"title":"Guloader Deobfuscation using Ghidra","uri":"/guloader-deobfuscation-using-ghidra/"},{"categories":["Malware Analysis"],"content":"Automation using Ghidra API’s Analyzing the shellcode dynamically will be very tiring because it has multiple checks for Anti-Analysis . Static Analysis will also take much time due to Control Flow Obfusucation. So I wrote 2 Scripts to help in this Analysis . one is to Deobfuscate the Control Flow and the other is to Decrypt the Strings Please Follow the Below Steps to Reduce your time on Guloader Import the Shellcode to Ghidra Disassemble (Key Binding D) the Start of the Shell code Run the Guloader_deobfusucate.py script Providing the Decryption Key and key for EIP modification Run the Gu_string_decryption.py script Providing the Decryption Key NOTE: For Both Cases Provide the keys as Hex String with out Ox Example if the key is 0x6A Provide it as 6A. My Scripts are not the best way to Achieve this . Note to Self need to improve to write better code After these Steps the Control Flow will be Deobfusucated and Decrypted Strings and Payload key will be printed in the Console . If you have a closer look at the below image you will see the C2 URl will not be starting with http:// this is to prevent it from XOR Bruteforcing I Have only Checked one sample with the scripts .Feel free to use it with Other Guloader Shell Code and let me know if you are able to see the Decrypted strings File SHA1 : 992d98aa6f31ae6f8f42fac9866a19c2a2f879be ","date":"2023-07-23","objectID":"/guloader-deobfuscation-using-ghidra/:3:0","tags":null,"title":"Guloader Deobfuscation using Ghidra","uri":"/guloader-deobfuscation-using-ghidra/"},{"categories":["Malware Analysis"],"content":"References SonicWall CheckPoint AnyRun ","date":"2023-07-23","objectID":"/guloader-deobfuscation-using-ghidra/:4:0","tags":null,"title":"Guloader Deobfuscation using Ghidra","uri":"/guloader-deobfuscation-using-ghidra/"},{"categories":["Tool Guide"],"content":"Malware String Decryption in 2 ways","date":"2023-04-16","objectID":"/malware-string-decryption-in-2-ways/","tags":null,"title":"Malware String Decryption in 2 ways","uri":"/malware-string-decryption-in-2-ways/"},{"categories":["Tool Guide"],"content":"Hi all, Today I am writing a blog about Decrypting malware strings using 2 ways. I have posted a tweet about this 2 days ago . The 2 Ways are Emulating Scripting ","date":"2023-04-16","objectID":"/malware-string-decryption-in-2-ways/:0:0","tags":null,"title":"Malware String Decryption in 2 ways","uri":"/malware-string-decryption-in-2-ways/"},{"categories":["Tool Guide"],"content":"Emulating For Emulation i used the tool dumpulator by mrexodia. To use the tool we needed to find the decryption function, it’s calling Convetion and the parameters being passed in this Example the function uses __fastcall calling convention and it has 4 parameters first 2 parameters are in ECX, EDX. the last parameters are pushed to the stack. with this understanding i wrote a small snippet for emulation from dumpulator import Dumpulator dp = Dumpulator(\"loki.dump\", quiet = \"TRUE\" ) dp.regs.ecx = 0x004eac00 dp.regs.edx = 0x30f dp.call(0x004b9b50,[0x004f8a4c, 0x004f8a34 ]) decrypted_string = dp.read(0x004eac00, 0x30f) print(decrypted_string.decode('latin-1')) First i loaded the PE file in x64dbg. Ran untill Entrypoint. and took a minidump.The minidump command has been integrated into x64dbg since 2022-10-10. To create a dump, pause execution and execute the command MiniDump \u003cfullpath_to_store_dmp\u003e I set ECX and EDX register using dp.regs.\u003cregister_name\u003e. The call method is having 2 arguments 1st argument is the function to be called. 2nd arguemnt is an array containning parameters of the function pushed to stack.read method has 2 arguments. 1st argument is the address to read data from. 2nd argument in the size of the Data ","date":"2023-04-16","objectID":"/malware-string-decryption-in-2-ways/:1:0","tags":null,"title":"Malware String Decryption in 2 ways","uri":"/malware-string-decryption-in-2-ways/"},{"categories":["Tool Guide"],"content":"Scripting I used python to decrypt the strings. I opened the PE File in Ghidra and Visited the decryptor function . it was using a simple XOR operation import binascii key = 0x5F5F5F5F final = \"\" hlast = \"\" data = \"5928270c3a2d293a2d73bf5e5fc109363a28732c2e33323e31382d730d1e382a36732c2a2f3a2d29362c3a731c2a332b2a2d3a731b3a39283e2b3c377328363128302d3b730e1d086c6d730e1d1b1d12382d732e3d2a2f3b3e2b3a733e27333d2d363b383a73372b2b2f3b73393b333e2a313c373a2d73122c1b2b0c2d292d73353e293e736c696f2c3a736c696f3b303c2b302d73283b2c28392c3e393a73393b37302c2b73181b2c3c3e317305372a1b303138193e3138062a730e1d1b23525f73117332262c2e333b731e2a2b303b3a2c341b3a2c342b302f1e2f2f733e3c283a3d3d2d30282c3a2d731c2d3a3e2b36293a7f1c33302a3b731e3b303d3a7f8d5a7f0c3343563c3a731c302d3a0c26313c73e75c531c1a1973173a332f3a2d7331303b3aeb5d5f5c160f1c1d2d30343a2d732c26313c722b3e2c343d3e8c5e28302d3f5c5f5d16312f2a2b0f3a2d2c30313e3336253e2b363031ef585c1c3033333e3dd7535f451d2d1c2b2d331c312b2d731d2d1c3c0a270c262c730c36322f33261c3031313a3c2b363031123e313e383a2d835d5f54710c262c2b3a320b2d3e26163c303173393d382a3e2d3b73393d2c3a2d3b665510111a11100b1a1273282c3e00335d5f5c363c3a7334303e3326723a272f723a313836313a72bf5c5e0b3a3e3230613a2d00bf7f77175f5b732b2900286c6d275f5f5627696b730b362b3e3109730c2c322c7331302b3a2f3e3b730d3b2d3b7b5f5a2c3e3273302d3e3c333a73303c2c2c3b733b3d2c31322fc77c5f5c2b36323a733e38312b2c293c73362c2e332f332a2c315e2739275f2d47322624692b302fa74d54303c3e2a2b302a2f3b2c733a313c2f5a562b3d362d3b3c30313936387378e75f5f582e302c73303c303232733b3d3a31386a6f732c2e3d3c302d3aa3575f003a273c3a3373363139302f3e2b3773322c3e3c3c3a2c2c73322c2f2a3d7330313a31302b3a73302a2b33303034732f30283a2d2f312b732c2b3a3e32732b373a3d3e2b732b372a313b3a2d3d362d3b7329362c36307328302d3b2f3e3b733d3a3b3d37732927323031733d3a313a2b312c235f5538363a31732f29332c292d733dd74e553a2d732d3e28003e383a312b002b4656292c313e2f292c2c731c3e38a3715e1b3a3333ef645f561b3a2b3a3c2b731a312b3a2d2f2d362c3a1c33363a312b730f2d302848173e3c3b13cb5e5e272f696be35d5f5b272f7318333e2c2c08362d3a7318081c2b330c2d29732b5e5f5b0c373e2d34733b2a322f3c3e2f73356f38313534306ecb3a5e2d2a312c787d5f696b76765f3e78725f3c777b5f76db5f573c696b3e730c262c323031875f5e696b732f3f4b364d3ed75e335c345d3230318f5cdb5e563e731e1b1a272f33302d3a2d76775f2f5478035f2b545e2b3c2f2927ce805f696b73787b5f5f4d3e733e2925732b3b2c2c343633333a2d730d3e3c3c36313a1a333a293e2b3a3b1c393873975d5a0c3a2b2b3631382cb75b5e00276769b35e5e730c2e33371a5d2d730d0b09dfd35e2c2e333d8bda552b30323c3e2b69730e1d161b0faf6b810174742c412b3a3278435cfb68a75ea75a6c0b5f373659302b3e333c323b730b9f5e5f5c696b73093a3a3e321b3a2f333026323a312b0c293c4e5f5f\"; for i in range(0,2380,8): hexa = int(data[i:i+8], 16) resulta = hexa ^ key resullta = resulta \u0026 0xFFFFFFFF final = hex(resulta) while (len(final) \u003c 10 ): final = final[0:2] + \"0\" + final[2:] final = final[2:] hlast += final decrypted_string = binascii.unhexlify(hlast.encode('latin-1')).decode('latin-1') print(decrypted_string) The key used was 0x5F5F5F5F. The script basically loops the contents of data to XOR it with the key. NOTE : My Python is not so good. I think it can be done in a better way ","date":"2023-04-16","objectID":"/malware-string-decryption-in-2-ways/:2:0","tags":null,"title":"Malware String Decryption in 2 ways","uri":"/malware-string-decryption-in-2-ways/"},{"categories":["Tool Guide"],"content":"References mrexodia OALabs ","date":"2023-04-16","objectID":"/malware-string-decryption-in-2-ways/:3:0","tags":null,"title":"Malware String Decryption in 2 ways","uri":"/malware-string-decryption-in-2-ways/"},{"categories":["Reverse Engineering"],"content":"Analysing Shellcode to understand how they call windows API's","date":"2022-12-28","objectID":"/analysing-shellcode-to-understand-how-they-call-windows-apis/","tags":null,"title":"Analysing Shellcode to understand how they call windows API's","uri":"/analysing-shellcode-to-understand-how-they-call-windows-apis/"},{"categories":["Reverse Engineering"],"content":"Introduction Hi all, Today we will be Analysing Shellcode to understand how they call windows API’s. shellcode’s are position independent, they do not have IAT to call API’s. They normally walk the PEB(Process Environment Block).To understand theory on how PEB is used to get API’s please read this article We will follow how a malware use this technique to call windows API’s . ","date":"2022-12-28","objectID":"/analysing-shellcode-to-understand-how-they-call-windows-apis/:1:0","tags":null,"title":"Analysing Shellcode to understand how they call windows API's","uri":"/analysing-shellcode-to-understand-how-they-call-windows-apis/"},{"categories":["Reverse Engineering"],"content":"Analysis The malware First allocates memory and copies the shellcode from the rsrc section to the allocated memory Then it gets the TEB (fs[18]) , after that it uses TEB to get the PEB (fs[30]). from the PEB it gets PEB_LDR_DATA ([PEB]+0c). from PEB_LDR_DATA it gets InInitilizationOrderModuleList([PEB_LDR_DATA] + 1c). Then it gets the BsaeDLL name to check if 10th char is “.” (for detecting kernel32.dll).This Data strucure is called LDR_DATA_TABLE_ENTRY. this table also contains other important Data like DLLBase, Entrypoint, SizeOfImage. To understand more about this Structures i would ask you to read this article After getting the DLLBase, we can get to e_lfanew(DLLbase+3c). From there we can go to the Exports Directory (DLLbase+ e_lfanew + 78).Exports Directory contains data Like Address of names,Address of functions,Address of named ordinals,Number of names. These Data are used to Hash all the API\"s and see if it Matches. You can refer this site to learn more about PE File format offsets An example of malware which uses the hashes of LoadLibraryExW and GetProcAddress to resolve them can be seen below After this stack strings of DLL’s are created and loaded using LoadlibraryExW ","date":"2022-12-28","objectID":"/analysing-shellcode-to-understand-how-they-call-windows-apis/:2:0","tags":null,"title":"Analysing Shellcode to understand how they call windows API's","uri":"/analysing-shellcode-to-understand-how-they-call-windows-apis/"},{"categories":["Reverse Engineering"],"content":"References imphash securitycafe sunshine2k. ","date":"2022-12-28","objectID":"/analysing-shellcode-to-understand-how-they-call-windows-apis/:3:0","tags":null,"title":"Analysing Shellcode to understand how they call windows API's","uri":"/analysing-shellcode-to-understand-how-they-call-windows-apis/"},{"categories":["Tool Guide"],"content":"Improving My Ghidra GUI + Ghidra Skills","date":"2022-11-23","objectID":"/improving-my-ghidra-gui--ghidra-skills/","tags":null,"title":"Improving My Ghidra GUI + Ghidra Skills","uri":"/improving-my-ghidra-gui--ghidra-skills/"},{"categories":["Tool Guide"],"content":"Hi all, Today I am writitng this post to let you know how i improved My Ghidra GUI \u0026 Ghidra Skills. We will be Discussing the below topics Customizing Code Browser Key Bindings Ghidra Extensions Ghidra Scripting ","date":"2022-11-23","objectID":"/improving-my-ghidra-gui--ghidra-skills/:0:0","tags":null,"title":"Improving My Ghidra GUI + Ghidra Skills","uri":"/improving-my-ghidra-gui--ghidra-skills/"},{"categories":["Tool Guide"],"content":"Customizing Code Browser Ghidra CodeBrowser has many Windows which helps in our analysis. My aim was to reduce switchig between Windows as less as possible. So I found the Windows i used the most and Combined them in the Main CodeBrowser Window. The Sections in My CodeBrowser Windows are Symbol Tree Data Type Manager Listing Window Function Graph Function Call Graph Decompiler Defined Strings Console Bookmarks Python I won’t recommend you to use this Same Sections. Try to find the Windows you use the most and Combine them in the CodeBrowser. You Can add this Windows by Visiting Windows \u003e “Windows you want to View”. After that adjust them by dragging the Windows Ghidra Lets you Cutomize the Code Browser by Visiting Edit \u003e Tool Options. An option which helped me a lot is Cursor Text Highlighting: Click Edit \u003e Tool Options Under Cursor Text Highlight select “Mouse Button to Activate” to “LEFT” (This will highlight the occurence of a selected string in Listing/Decompiler Window) ","date":"2022-11-23","objectID":"/improving-my-ghidra-gui--ghidra-skills/:1:0","tags":null,"title":"Improving My Ghidra GUI + Ghidra Skills","uri":"/improving-my-ghidra-gui--ghidra-skills/"},{"categories":["Tool Guide"],"content":"Key Bindings Ghidra Key Bindings helps you to perform actions related to Ghidra. Ghidra Has So many default KeyBindings Full List of Key Bindings. Ghidra also help you to add custom Key Bindings by visiting Edit \u003e Tool Options \u003e Key Binding. Here is a list of Key Bindings(Default + Custom) I use the most L : Edit Label / Rename Function / Rename Variable Ctrl + L : Retype Variable T: Choose Data Type X: Show Xrefs TO Shift + [ = Create Structure F3 = Edit Function Signature C = Clear Code D = Disassemble Find the actions you perform the Most. look if there is a Key Binding for it. if not add a custom Key Binding. Setting Key Bindings for most used actions is a good practice ","date":"2022-11-23","objectID":"/improving-my-ghidra-gui--ghidra-skills/:2:0","tags":null,"title":"Improving My Ghidra GUI + Ghidra Skills","uri":"/improving-my-ghidra-gui--ghidra-skills/"},{"categories":["Tool Guide"],"content":"Ghidra Extensions Ghidra Extensions help you to import other features which are not in Ghidra. You can install a Ghidra Extension in GUI by going to Ghidra project Manager Window. Click File → Install Extensions Click on the ‘+’ icon in the Top right Select the folder Which Contain the Ghidra Extension After Importing Make sure Box under the Extension you want to install is Checked Click OK and Restart Ghidra Find the Ghidra Documentation for extensions Here .These are the Two Extensions i have found usefull Ghidrathon : The FLARE team’s open-source extension to add Python 3 scripting to Ghidra. Kaiju : Kaiju is a binary analysis framework extension for the Ghidra software reverse engineering suite ","date":"2022-11-23","objectID":"/improving-my-ghidra-gui--ghidra-skills/:3:0","tags":null,"title":"Improving My Ghidra GUI + Ghidra Skills","uri":"/improving-my-ghidra-gui--ghidra-skills/"},{"categories":["Tool Guide"],"content":"Ghidra Scripting Ghidra Supports Scripting in multiple languages. I use python for scripting in Ghidra. Ghidra API is very powerfull that we can replace a Multiline code with a single Ghidra API function Call.I will Show some of the Cool Ghidra API Functions Belw find(Address addr, byte[] values) : Searches memory from ‘addr’ for ‘values’ and returns the address of ‘values’ if it is found getBytes(Address addr, int length) : Return ’length’ bytes from memory starting from ‘addr’ getReferencesto( Address addr) : Get All the XREF’s to addr setEOLComment(Address addr, String message): Add an EOLComment at ‘addr’ which has the comment ‘message’ createBookmark(Addres addr, String category, String note): Creates a NOTE bookmark at ‘addr’ toAddr​(String addressString) : Returns a new address inside the specified program as indicated by the ‘addressString’. This the just a tip of the iceberg. There so many other Functions in the Ghidra API . Refer this for more details Here is a Ghidra Script i wrote to Decrypt an XOR encrypted Sring table from ghidra.app.decompiler import DecompileOptions from ghidra.app.decompiler import DecompInterface from ghidra.util.task import ConsoleTaskMonitor def decrypter(data_string, data_key): decoded = '' for i in xrange(0, len(data_string): decoded += chr((data_string[i]) ^ (data_key[i % len(data_key)])) return decoded enc_address_start = askAddress(\"Provide Address of Encrypred String\", \"Address\") enc_address_end = find(enc_address_start, [00, 00]) len_address = int(str(enc_address_end), 16) - int(str(enc_address_start), 16) data = getBytes(enc_address_start, len_address) key_address_start = askAddress(\"Provide Address of Key String\", \"Address\") key_address_end = find(key_address_start, [00, 00]) len_address_key = int(str(key_address_end), 16) - int(str(key_address_start), 16) key = b'' key = getBytes(key_address_start, len_address_key) global decoded decoded = decrypter(data, key) mw_decrypt = askAddress(\"Provide Address of decrypt function\", \"Address\") refs = getReferencesTo(mw_decrypt) options = DecompileOptions() monitor = ConsoleTaskMonitor() ifc = DecompInterface() ifc.setOptions(options) ifc.openProgram(currentProgram) for xref in refs: i = xref.getFromAddress() func = getFunctionContaining(i) res = ifc.decompileFunction( func, 60, monitor) high_func = res.getHighFunction() pcodeops = high_func.getPcodeOps(i) op = pcodeops.next() print(str(i)) param = op.getInputs() offset = str(param[1]).split(\",\") offset_1 = offset[1] offset_int = int(offset_1.lstrip(), 16) decrypted_string = decoded[offset_int:].split(\"\\x00\")[0] print(decrypted_string) setEOLComment (i, decrypted string) ","date":"2022-11-23","objectID":"/improving-my-ghidra-gui--ghidra-skills/:4:0","tags":null,"title":"Improving My Ghidra GUI + Ghidra Skills","uri":"/improving-my-ghidra-gui--ghidra-skills/"},{"categories":["Tool Guide"],"content":"References The Ghidra Book exploitreversing Awesome Ghidra Matthew ","date":"2022-11-23","objectID":"/improving-my-ghidra-gui--ghidra-skills/:5:0","tags":null,"title":"Improving My Ghidra GUI + Ghidra Skills","uri":"/improving-my-ghidra-gui--ghidra-skills/"},{"categories":["Malware Analysis"],"content":"Unmapping PE files, fixing Alignment and Fixing coruupted/Missing PE Header","date":"2022-09-30","objectID":"/unmapping-pe-files-fixing-alignment-and-fixing-corrupted-or-missing-pe-header/","tags":null,"title":"Unmapping PE files, fixing Alignment and Fixing corrupted/Missing PE Header","uri":"/unmapping-pe-files-fixing-alignment-and-fixing-corrupted-or-missing-pe-header/"},{"categories":["Malware Analysis"],"content":" Hi all, Today I am writing this Post to help you fix the common problems faced while unpacking malware They are Unmapping PE files Fixing Alignment and Fixing corrupted/Missing PE Header First we will be Discussing how to Unmap PE file ","date":"2022-09-30","objectID":"/unmapping-pe-files-fixing-alignment-and-fixing-corrupted-or-missing-pe-header/:0:0","tags":null,"title":"Unmapping PE files, fixing Alignment and Fixing corrupted/Missing PE Header","uri":"/unmapping-pe-files-fixing-alignment-and-fixing-corrupted-or-missing-pe-header/"},{"categories":["Malware Analysis"],"content":"Unmapping PE files While Unpacking malware we dump the mapped binary into file. For proper analysis we need to convert this to an Unmapped Binary. We can make sure that the binary is mapped by looking at the raw address of first section, it will be always 1000 . For unmapped binaries the first section starts at 400. The tools we will be using are PE-bear and HxD Purpose The purpose of unmapping a File is to make the sections line up correctly.In the mapped PE, sections are not lined up correctly due to this we cannot see informations like imports and exports of the PE. By unmapping we can make the sections line up correctly and view informations like imports and exports of the PE Steps Open the File in PE-bear go to the Section Hdrs tab Make the Raw address match the Virtual address of Sections Set the Raw size and Virtual size correctly using this formula Raw size of Section n = VA of section n+1 - VA of section n Ex : Raw size of first Section(.text 22000) = Virtual Address of Section 2 (.rdata = 23000) - Virtual Address of Section 1 (.text = 1000) Follow this formula for all Other section except reloc Make the Virtual Size match the Raw size for all sections except reloc Make reloc size 0 Because reloc section only exist in disk . since we have dumped the pe from memory it won’t have reloc section Go to Optional Header tab and make sure the image base is same as the packed binary’s image Base This is the Final Unmapped PE. Save It ","date":"2022-09-30","objectID":"/unmapping-pe-files-fixing-alignment-and-fixing-corrupted-or-missing-pe-header/:1:0","tags":null,"title":"Unmapping PE files, fixing Alignment and Fixing corrupted/Missing PE Header","uri":"/unmapping-pe-files-fixing-alignment-and-fixing-corrupted-or-missing-pe-header/"},{"categories":["Malware Analysis"],"content":"Fixing Alignment and Fixing corrupted/Missing PE Header While Unpacking malware some malware authors corrupt the PE headers of unpacked sample. So after Dumping the memory we need to add PE header to the file Steps First add the correct PE header : Look for 4c 01 / 64 86 (CPU architecture in optional header ) open the corrupted file and a known good PE file and copy and paste the PE header of good file ( till 4c0 1 / 64 86) using HxD to the corrupted file ( till 4c 01 / 64 86) Check and fix section alignment : Move to raw address of Section 1 .Is the byte zeroed out correctly till the start ,if not add null (00) bytes till the start of section 1 using HxD ","date":"2022-09-30","objectID":"/unmapping-pe-files-fixing-alignment-and-fixing-corrupted-or-missing-pe-header/:2:0","tags":null,"title":"Unmapping PE files, fixing Alignment and Fixing corrupted/Missing PE Header","uri":"/unmapping-pe-files-fixing-alignment-and-fixing-corrupted-or-missing-pe-header/"},{"categories":["Malware Analysis"],"content":"References OALabs exploitreversing ","date":"2022-09-30","objectID":"/unmapping-pe-files-fixing-alignment-and-fixing-corrupted-or-missing-pe-header/:3:0","tags":null,"title":"Unmapping PE files, fixing Alignment and Fixing corrupted/Missing PE Header","uri":"/unmapping-pe-files-fixing-alignment-and-fixing-corrupted-or-missing-pe-header/"},{"categories":null,"content":"About Me","date":"2022-09-29","objectID":"/about/","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":" Hi all. I am irfan_eternal. Malware analyst interested in Reverse Engineering. I have been working in the Blue Side for 2 years. I love analysing malwares because It is more of a puzzle. where we are trying to identify what it does by defeating anti-analysis techniques ","date":"2022-09-29","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"Skills Static and Dynamic Malware Analysis Analysis of Web Attacks Reverse Engineering Automation YARA Rule Creation to detect Malware ","date":"2022-09-29","objectID":"/about/:0:1","tags":null,"title":"About Me","uri":"/about/"}]